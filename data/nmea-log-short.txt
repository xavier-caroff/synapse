$aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
123456789012345678901234567890123456789012345678901234567890
         1         2         3         4         5         6
$bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
$ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
$ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd
$eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
$fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
$ggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg
$hhhh$hhhhhh$hhhhhhh$hhhhhhhh
$iiiiiiiiiiiiiiiiiiiii$i
$jjjjjjjjjjjj$
kkkkkkkkkkkkkkkkkkkkk$llllllllll
$mmmmmmmm
$nnnn
	// Check other options
	if (!found)
	{
		po::variables_map       vm;
		po::options_description cmdlineOptions;

		cmdlineOptions.add(serveOptionsDescription);

		po::positional_options_description positionalOptions;

		positionalOptions.add("file", 1);

		store(po::command_line_parser(argc, argv).options(cmdlineOptions).positional(positionalOptions).run(), vm);
		notify(vm);

		result = RunningMode::serve;
		found  = true;
	}

	// Show usage if requested.
	if (showUsage)
	{
		std::stringstream os;

		os << synapse::framework::getVersion().description << " - " << synapse::framework::getVersion().version
		   << std::endl
		   << std::endl
		   << "Usage: msg-server { -h | -v | {options} config }" << std::endl;

		po::options_description cmdlineOptions;

		cmdlineOptions
			.add(helpOptionsDescription)
			.add(versionOptionsDescription)
			.add(serveOptionsDescription);
		os << cmdlineOptions;

		ui()->display(os.str());
	}

	return result;
}

// Display version information.
void Application::showVersion()
{
	ui()->version(
		synapse::framework::getVersion().major,
		synapse::framework::getVersion().minor,
		synapse::framework::getVersion().micro,
		synapse::framework::getVersion().description);
}

// Launch the server.
Application::ExitCode Application::serve(
	const ServeOptions& options)
{
	ExitCode                result = ExitCode::success;
	boost::asio::io_context ioc;

	// Capture SIGINT and SIGTERM to perform a clean shutdown
	boost::asio::signal_set signals(ioc, SIGINT, SIGTERM);
	signals.async_wait(
		[&](boost::system::error_code const&, int) {
			// Stop the `io_context`. This will cause `run()`
			// to return immediately, eventually destroying the
			// `io_context` and all of the sockets in it.
			ioc.stop();
		});

	// Extract configurationfrom command line arguments.
	auto                     duration = std::chrono::duration_cast<boost::asio::steady_timer::duration>(std::chrono::duration<double>(options.delay));
	boost::asio::ip::address address;

	if (result == ExitCode::success)
	{
		boost::asio::ip::tcp::resolver resolver(ioc);
		auto                           results = resolver.resolve(options.address, std::to_string(options.port));

		if (results.empty())
		{
			ui()->message(IUserInterface::Severity::error, "Unable to resolve address");
			result = ExitCode::invalidAddress;
		}
		else
		{
			address = results.begin()->endpoint().address();
		}
	}

	// Run the server.
	if (result == ExitCode::success)
	{
		Server server(
			ioc, ui(), boost::asio::ip::tcp::endpoint(address, options.port), duration, options.file, options.blockSize);

		// Start serving.

		ioc.run();

		ui()->message(IUserInterface::Severity::info, "The Server is stopped");
	}

	return result;
$SDDPT,11.3,-1.0,99.0*7A
$HCHDG,331.3,00.0,E,00.0,E*40
$WIMWV,025.4,R,016.3,N,A*24
$VWVHW,129.0,T,129.0,M,07.7,N,14.3,K*52
